#include <SDL.h>
#undef main
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "SDL_opengl.h"
#include <SDL_image.h>
#include <string.h>
#include <time.h>

#define quantBlocos 15 //quantidade de blocos a serem criados no cenário

//criar a imagem no programa
GLuint loadtexture(const char* filename)
{
    SDL_Surface* imagem = IMG_Load(filename); //carrega a imagem
    SDL_DisplayFormatAlpha(imagem);
    unsigned textura(0); //cria uma textura
    glGenTextures(1, &textura); //gera a textura
    glBindTexture(GL_TEXTURE_2D, textura); //informa o tipo de textura

    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, imagem -> w, imagem -> h, 0, GL_RGBA, GL_UNSIGNED_BYTE, imagem -> pixels);

    SDL_FreeSurface(imagem);

    return textura;
}

//função da colisão
//bloco1 - inimigo
//bloco2 - personagem
bool colisao(float bloco1X, float bloco1Y, float bloco1Comp, float bloco1Alt, float bloco2X, float bloco2Y, float bloco2comp, float bloco2alt)
{
    if(bloco1Y+bloco1Alt <= bloco2Y)
        return false;
    else if(bloco1Y >= bloco2Y+bloco2alt)
        return false;
    else if(bloco1X+bloco1Comp <= bloco2X)
        return false;
    else if(bloco1X >= bloco2X+bloco2comp)
        return false;

    return true;
}


//struct para criar os obstaculos
struct Bloco
{
    float X;
    float Y;
    float comp;
    float alt;

    bool destroi;
};

int main(int argc, char **argv[])
{

    bool tiro = false;

//------------inicio dos processos iniciais para criação da janela e definição de atributos--------------------------------------------//
	//inicializa tudo
	SDL_Init(SDL_INIT_EVERYTHING);

    glDisable(GL_BLEND);

    //diminuindo o uso da memória
    SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_BUFFER_SIZE, 32);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16);
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);

    //criando janela, definindo tamanho, cor e mostrando porç~çao da janela

    SDL_WM_SetCaption("mate ou morra", NULL);

    SDL_SetVideoMode(1080, 768, 32, SDL_OPENGL);

    glClearColor(1, 1, 1, 0);

    glViewport(0, 0, 1080, 768);

    //sombreamento da janela

    glShadeModel(GL_SMOOTH);

    //2d
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity(); //desenhos geometricos;

    //3d - disabilitar
    glDisable(GL_DEPTH_TEST);

    //para usar a imagem da função la de cima
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);


    //-----lógica-----//
    bool executando = true;

    SDL_Event click;

    //variaveis do personagem
    float posX = 540;
    float posY = 750;
    float compr = 50;
    float altur = 50;

    //variaveis do inimigo
    srand((unsigned)time(NULL));
    float posX1 = rand()%1031;
    float posY1 = 50;
    float compr1 = 50;
    float altur1 = 50;

    float velX = 5;
    float velY = 5;


    //variaveis do tiro
    float tiroX= 565;
    float tiroY= 750;
    float tiroCompr= 3;
    float tiroAltur= 6;

    float velTiroY= -5;

    //declarando e criando os blocos
    Bloco blocos[quantBlocos];


    for(int i = 0, x = 4, y = 150, cont = 0; i < quantBlocos; cont++, i++, x += 250)
    {

        if(x > 1010)
        {
            x = 4;
            y += 150;
        }

        blocos[i].X = x;
        blocos[i].Y = y;
        blocos[i].comp = 60;
        blocos[i].alt = 20;
        blocos[i].destroi = true;
    }


    bool esq = false;
    bool dir = false;

    unsigned int personTextura = 0;
    personTextura = loadtexture("imagens/detetive.png");

    unsigned int inimigoTextura = 0;
    inimigoTextura = loadtexture("imagens/spritedetetive3.png");

    unsigned int backTexture = 0;
    backTexture = loadtexture("imagens/background.png");

    unsigned int obstaculo = 0;
    obstaculo = loadtexture("imagens/obstaculo.png");

    unsigned int tiroTextura = 0;
    tiroTextura = loadtexture("imagens/tiro.png");


    //while principal do jogo
    while(executando)
    {

        //eventos
        while (SDL_PollEvent(&click))
        {
            if(click.type == SDL_QUIT)
            {
                executando = false;
            }
            if (click.type == SDL_KEYDOWN && click.key.keysym.sym == SDLK_ESCAPE)
            {
                executando = false;
            }
            if(click.type == SDL_KEYDOWN) // tecla é pressionada
            {
                if(click.key.keysym.sym == SDLK_a)
                {
                    esq = true;
                }
                else if(click.key.keysym.sym == SDLK_d)
                {
                    dir = true;
                }
                else if(click.key.keysym.sym == SDLK_0)
                {
                    tiro = true;
                }
            }
            else if(click.type == SDL_KEYUP) // tecla é solta
            {
                if(click.key.keysym.sym == SDLK_a)
                {
                    esq = false;
                }
                else if(click.key.keysym.sym == SDLK_d)
                {
                    dir = false;
                }
            }
        }

        //movimento do personagem
        if(esq == true)
        {
            posX-= 5;
        }
        else if(dir == true)
        {
            posX+= 5;
        }

        //logica do personagem

        if(posX < 0)
        {
            posX = 0;
        }
        else if(posX+altur > 1080)
        {
            posX = 1080 - compr;
        }
        else if(posY < 0)
        {
            posY = 0;
        }
        else if(posY+altur > 768)
        {
            posY = 768 - altur;
        }


        //movimento do tiro

        tiroY += velTiroY;


        //movimento do inimigo
        posX1 += velX;

        for(int i = 0; i <quantBlocos; i++)
        {
            if(blocos[i].destroi == true)
            {
                if(colisao(posX1, posY1, compr1, altur1, blocos[i].X, blocos[i].Y, blocos[i].comp, blocos[i].alt) == true)
                {
                    velX = -velX*1.09;
                    blocos[i].destroi = false;
                    break;
                }
            }
        }

        posY1 += velY;
        for(int i = 0; i <quantBlocos; i++)
        {
            if(blocos[i].destroi == true)
            {
                if(colisao(posX1, posY1, compr1, altur1, blocos[i].X, blocos[i].Y, blocos[i].comp, blocos[i].alt) == true)
                {
                    velY = -velY*1.09;
                    blocos[i].destroi = false;
                    break;
                }
            }
        }

        //logica do inimigo
        if(posX1 < 0)
        {
            velX = -velX;
        }
        else if(posX1+altur1 > 1080)
        {
            velX = -velX;
        }
        else if(posY1 < 0)
        {
            velY = -velY;
        }
        else if(posY1+altur1 > 768)
        {
            //executando = false;
            velY = -velY;
        }

        if(colisao(posX1, posY1, compr1, altur1, posX, posY, compr, altur) == true)
        {
            velY = -velY;
           // velX = velX;
        }

        //movimento do tiro


        //-----renderização------+//
        glClear(GL_COLOR_BUFFER_BIT); // limpa o buffer bit a bit

        //inicia matriz de desenho
        glPushMatrix();

        //dimenssões da matriz
        glOrtho(0, 1080, 768, 0, -1, 1);

        //background
        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, backTexture);

        // quad of the background
        glBegin(GL_QUADS);
        glColor4ub(255, 255, 255, 255);

        glTexCoord2d(0,0);
            glVertex2f(0,0);
        glTexCoord2d(1,0);
            glVertex2f(1080,0);
        glTexCoord2d(1,1);
            glVertex2f(1080,768);
        glTexCoord2d(0,1);
            glVertex2f(0,768);

        glEnd();
        glDisable(GL_TEXTURE_2D);


        //inicia o desenho do personagem

        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, personTextura);

        //cores
        glColor4ub(255, 255, 255, 255);

        glBegin(GL_QUADS);

        glTexCoord2d(0,0);
            glVertex2f(posX, posY);
        glTexCoord2d(1,0);
            glVertex2f(posX+compr, posY);
        glTexCoord2d(1,1);
            glVertex2f(posX+compr, posY+altur);
        glTexCoord2d(0,1);
            glVertex2f(posX, posY+altur);

        //termina o desenho do personagem
        glEnd();
        glDisable(GL_TEXTURE_2D);


        //inicia o desenho inimigo

        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, inimigoTextura);

        glBegin(GL_QUADS);
        glColor4ub(255, 255, 255, 255);

        glTexCoord2d(0,0);
            glVertex2f(posX1, posY1);
        glTexCoord2d(1,0);
            glVertex2f(posX1+compr1, posY1);
        glTexCoord2d(1,1);
            glVertex2f(posX1+compr1, posY1+altur1);
        glTexCoord2d(0,1);
            glVertex2f(posX1, posY1+altur1);

        //termina o desenho do inimigo
        glEnd();
        glDisable(GL_TEXTURE_2D);


        //criação dos obstaculos
        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, obstaculo);

        glBegin((GL_QUADS));
        glColor4ub(255, 255, 255, 255);

        for(int i = 0; i < quantBlocos; i++)
        {
            if(blocos[i].destroi == true)
            {
                glTexCoord2d(0,0);
                    glVertex2f(blocos[i].X, blocos[i].Y);
                glTexCoord2d(1,0);
                    glVertex2f(blocos[i].X + blocos[i].comp, blocos[i].Y);
                glTexCoord2d(1,1);
                    glVertex2f(blocos[i].X + blocos[i].comp, blocos[i].Y + blocos[i].alt);
                glTexCoord2d(0,1);
                    glVertex2f(blocos[i].X, blocos[i].Y + blocos[i].alt);
            }
        }

        glEnd();
        glDisable(GL_TEXTURE_2D);

        //criação do tiro

        while(executando)
        {
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, tiroTextura);

            glBegin(GL_QUADS);
            glColor3ub(255,255,255);

            glTexCoord2d(0,0);
                glVertex2f(tiroX, tiroY);
            glTexCoord2d(1,0);
                glVertex2f(tiroX+tiroCompr, tiroY);
            glTexCoord2d(1,1);
                glVertex2f(tiroX+tiroCompr, tiroY+tiroAltur);
            glTexCoord2d(0,1);
                glVertex2f(tiroX, tiroY+tiroAltur);

            glEnd();
            glDisable(GL_TEXTURE_2D);
            break;
        }


        //fecha a matriz de desenho
        glPopMatrix();

        SDL_GL_SwapBuffers(); //usado para animações
    }

	SDL_Quit();

	return 0;
}
